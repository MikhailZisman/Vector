{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vector \u00b6 Vector is a Kotlin Coroutines based MVI Architecture library for Android. It is inspired from MvRx and Roxie , but unlike them it is built completely using Kotlin Coroutines instead of RxJava. As such, it internally only uses Coroutine primitives, and has extensive support for Suspending functions. Vector works well with Android Architecture Components. It is 100% Kotlin, and is intended for use with Kotlin only. Installation Instructions \u00b6 Add the Jitpack repository to your top level build.gradle file. allprojects { repositories { ... maven { url 'https://jitpack.io' } } } And then add the following dependency in your module's build.gradle file: dependencies { implementation \"com.github.haroldadmin:Vector:(latest-version)\" } R8/Proguard Config \u00b6 The library ships with consumer proguard rules, so no additional configuration should be required. License \u00b6 Copyright 2019 Vector Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#vector","text":"Vector is a Kotlin Coroutines based MVI Architecture library for Android. It is inspired from MvRx and Roxie , but unlike them it is built completely using Kotlin Coroutines instead of RxJava. As such, it internally only uses Coroutine primitives, and has extensive support for Suspending functions. Vector works well with Android Architecture Components. It is 100% Kotlin, and is intended for use with Kotlin only.","title":"Vector"},{"location":"#installation-instructions","text":"Add the Jitpack repository to your top level build.gradle file. allprojects { repositories { ... maven { url 'https://jitpack.io' } } } And then add the following dependency in your module's build.gradle file: dependencies { implementation \"com.github.haroldadmin:Vector:(latest-version)\" }","title":"Installation Instructions"},{"location":"#r8proguard-config","text":"The library ships with consumer proguard rules, so no additional configuration should be required.","title":"R8/Proguard Config"},{"location":"#license","text":"Copyright 2019 Vector Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"automatic-viewmodel-creation/","text":"Automatic ViewModel creation \u00b6 Vector ships with some lazy delegates for instantiating ViewModels automatically. val viewModel by fragmentViewModel () by activityViewModel () by viewModel () val viewModel by fragmentViewModel { initialState , savedStateHandle -> ... } by activityViewModel { initialState , savedStateHandle -> ... } by viewModel { initialState , savedStateHandle -> ... } These delegates use Reflection to instantiate your ViewModels. The process goes as follows: First, we try to create the initial state for your ViewModel using either the ViewModel factory or using the constructor. If the ViewModel implements VectorViewModelFactory in its companion object, we attempt to create initial state using it If the ViewModel does not implement that interface, or it does not override the initialState() method, then we attempt to create initial state using the state class constructor. For this to succeed, all properties in your state class must have default values. If both the strategies fail, we throw an exception and crash. Then, we try to create the ViewModel. If the delegate has been supplied a trailing lambda which tells us how to produce the ViewModel, we invoke it, register the ViewModel with the ViewModelProvider for the calling Activity/Fragment and return it. Otherwise, we check if the ViewModel implements VectorViewModelFactory in its companion object. If so, we attempt to create the ViewModel using its create method. If the ViewModel does not implement that interface or if the returned ViewModel is null, we try to create the ViewModel using its constructor. For this to succeed, the ViewModel must have one of the following constructors: ViewModel(initialState) ViewModel(initialState, savedStateHandle) ViewModel(initialState, stateStoreContext, logger) ViewModel(initialState, stateStoreContext, logger, savedStateHandle) If these conditions can not be met, we throw an exception and crash. Therefore, the ViewModel's VectorViewModelFactory is given priority for both tasks if it is implemented. Otherwise, we resort to constructor invocations.","title":"Automatic ViewModel Creation"},{"location":"automatic-viewmodel-creation/#automatic-viewmodel-creation","text":"Vector ships with some lazy delegates for instantiating ViewModels automatically. val viewModel by fragmentViewModel () by activityViewModel () by viewModel () val viewModel by fragmentViewModel { initialState , savedStateHandle -> ... } by activityViewModel { initialState , savedStateHandle -> ... } by viewModel { initialState , savedStateHandle -> ... } These delegates use Reflection to instantiate your ViewModels. The process goes as follows: First, we try to create the initial state for your ViewModel using either the ViewModel factory or using the constructor. If the ViewModel implements VectorViewModelFactory in its companion object, we attempt to create initial state using it If the ViewModel does not implement that interface, or it does not override the initialState() method, then we attempt to create initial state using the state class constructor. For this to succeed, all properties in your state class must have default values. If both the strategies fail, we throw an exception and crash. Then, we try to create the ViewModel. If the delegate has been supplied a trailing lambda which tells us how to produce the ViewModel, we invoke it, register the ViewModel with the ViewModelProvider for the calling Activity/Fragment and return it. Otherwise, we check if the ViewModel implements VectorViewModelFactory in its companion object. If so, we attempt to create the ViewModel using its create method. If the ViewModel does not implement that interface or if the returned ViewModel is null, we try to create the ViewModel using its constructor. For this to succeed, the ViewModel must have one of the following constructors: ViewModel(initialState) ViewModel(initialState, savedStateHandle) ViewModel(initialState, stateStoreContext, logger) ViewModel(initialState, stateStoreContext, logger, savedStateHandle) If these conditions can not be met, we throw an exception and crash. Therefore, the ViewModel's VectorViewModelFactory is given priority for both tasks if it is implemented. Otherwise, we resort to constructor invocations.","title":"Automatic ViewModel creation"},{"location":"introduction/","text":"Introduction \u00b6 Vector helps you build an app based on the Model-View-Intent architecture pattern. Hannes Dorfmann has written an excellent series of blog posts about this pattern, the links to which you can find at the bottom of this page. I won't try to explain in detail what MVI is, much more qualified people have already done so in great detail. This page contains only a small summary. Note Vector uses Experimental Coroutine API's under the hood, so the design of this library could change drastically as and when the design of Coroutines in the language evolves. MVI \u00b6 An app is essentially a collection of screens with which the user interacts. Each screen is called a View . Almost all screens in an app need some data to generate views to display on the screen. This data is called the Model . Views render UI elements to the screen based on the information contained in the Model. The user interacts with these UI elements, possibly triggering some 'actions' that mutate the UI state. These actions are called Intents . Intents are dispatched to a 'controller' of the screen, which mutates the Model based on the triggered action and produces a new one. The UI reacts to the updated model and re-renders itself based on the new data. Why use a library for this? \u00b6 In the version of MVI that I just described, we can see a clear pattern followed by each screen of the app. Setting up MVI this way requires you to create a lot of boilerplate code to get things up and running. Even then, things are difficult to get right in the first try. You have to make sure that mutations to the data model are processed sequentially even though the sources of actions may be asynchronous. Vector helps you with all these things. It takes care of most of the boilerplate, state mutations are always processed sequentially even though the sources of mutations be asynchronous, and it encourages clean architectural practices. Why use Vector for this? \u00b6 Granted, there are quite a lot of excellent MVI architecture libraries available for Android. Here are some of them, I encourage you to check them out: MvRx MvRx by AirBnb is an excellent library, and Vector draws a lot of its design from it. However, MvRx is heavily reliant on RxJava and has less than stellar support for Kotlin's suspending functions. It also tries to do a lot more than just simple state management, and is very close to being a framework rather than a library. Vector, on the other hand, is small and lightweight. It is also built completely using Kotlin Coroutines and therefore offers excellent support for suspending functions. It tries not to do a whole lot more than managing state, and therefore lets you freely choose how you want to design the rest of your app. Roxie Roxie is a small and lightweight library, just like Vector, but it also does not have great support for suspending functions. It also treats actions as a very well defined entity, something which Vector does not. Roxie recommends using a Kotlin Sealed Class to represent all possible actions that can be performed on a screen. It also recommends a very different pattern of reducers than what Vector does. Thus, while Roxie itself is quite small, the boilerplate that comes with it is not. Mobius Mobius is another popular MVI framework by Spotify, and is also recommended by a lot of developers in the community. Vector borrows from the design of both MvRx and Roxie, and I would like to sincerely thank the developers of both of them. Vector's approach to MVI \u00b6 Vector recommends using a Kotlin Data Class to represent the UI Model. Your model class should implement the VectorState interface. Intents are regular lambdas in Vector. State reducers are of the type S.() -> S , where S is a model class implementing the VectorState interface. Vector does not have an opinion regarding what Views should be in your app. We supply a convenient VectorFragment abstract class in the library, but it is not necessary to use it. While the sample app in the repository uses Fragments , you are free to choose whatever you like. The current state is exposed to the View through a Kotlin Flow object, so it helps if your View class is a CoroutineScope with. Building Blocks \u00b6 Vector State Vector Fragment Vector ViewModel Further Reading \u00b6 Hannes Dorfmann blog series on MVI MvRx: Android on Autopilot","title":"Introduction"},{"location":"introduction/#introduction","text":"Vector helps you build an app based on the Model-View-Intent architecture pattern. Hannes Dorfmann has written an excellent series of blog posts about this pattern, the links to which you can find at the bottom of this page. I won't try to explain in detail what MVI is, much more qualified people have already done so in great detail. This page contains only a small summary. Note Vector uses Experimental Coroutine API's under the hood, so the design of this library could change drastically as and when the design of Coroutines in the language evolves.","title":"Introduction"},{"location":"introduction/#mvi","text":"An app is essentially a collection of screens with which the user interacts. Each screen is called a View . Almost all screens in an app need some data to generate views to display on the screen. This data is called the Model . Views render UI elements to the screen based on the information contained in the Model. The user interacts with these UI elements, possibly triggering some 'actions' that mutate the UI state. These actions are called Intents . Intents are dispatched to a 'controller' of the screen, which mutates the Model based on the triggered action and produces a new one. The UI reacts to the updated model and re-renders itself based on the new data.","title":"MVI"},{"location":"introduction/#why-use-a-library-for-this","text":"In the version of MVI that I just described, we can see a clear pattern followed by each screen of the app. Setting up MVI this way requires you to create a lot of boilerplate code to get things up and running. Even then, things are difficult to get right in the first try. You have to make sure that mutations to the data model are processed sequentially even though the sources of actions may be asynchronous. Vector helps you with all these things. It takes care of most of the boilerplate, state mutations are always processed sequentially even though the sources of mutations be asynchronous, and it encourages clean architectural practices.","title":"Why use a library for this?"},{"location":"introduction/#why-use-vector-for-this","text":"Granted, there are quite a lot of excellent MVI architecture libraries available for Android. Here are some of them, I encourage you to check them out: MvRx MvRx by AirBnb is an excellent library, and Vector draws a lot of its design from it. However, MvRx is heavily reliant on RxJava and has less than stellar support for Kotlin's suspending functions. It also tries to do a lot more than just simple state management, and is very close to being a framework rather than a library. Vector, on the other hand, is small and lightweight. It is also built completely using Kotlin Coroutines and therefore offers excellent support for suspending functions. It tries not to do a whole lot more than managing state, and therefore lets you freely choose how you want to design the rest of your app. Roxie Roxie is a small and lightweight library, just like Vector, but it also does not have great support for suspending functions. It also treats actions as a very well defined entity, something which Vector does not. Roxie recommends using a Kotlin Sealed Class to represent all possible actions that can be performed on a screen. It also recommends a very different pattern of reducers than what Vector does. Thus, while Roxie itself is quite small, the boilerplate that comes with it is not. Mobius Mobius is another popular MVI framework by Spotify, and is also recommended by a lot of developers in the community. Vector borrows from the design of both MvRx and Roxie, and I would like to sincerely thank the developers of both of them.","title":"Why use Vector for this?"},{"location":"introduction/#vectors-approach-to-mvi","text":"Vector recommends using a Kotlin Data Class to represent the UI Model. Your model class should implement the VectorState interface. Intents are regular lambdas in Vector. State reducers are of the type S.() -> S , where S is a model class implementing the VectorState interface. Vector does not have an opinion regarding what Views should be in your app. We supply a convenient VectorFragment abstract class in the library, but it is not necessary to use it. While the sample app in the repository uses Fragments , you are free to choose whatever you like. The current state is exposed to the View through a Kotlin Flow object, so it helps if your View class is a CoroutineScope with.","title":"Vector's approach to MVI"},{"location":"introduction/#building-blocks","text":"Vector State Vector Fragment Vector ViewModel","title":"Building Blocks"},{"location":"introduction/#further-reading","text":"Hannes Dorfmann blog series on MVI MvRx: Android on Autopilot","title":"Further Reading"},{"location":"logging/","text":"Logging \u00b6 Vector can log state related actions. It ships with two different loggers: AndroidLogger: Writes log statements to Android log ( Log.* ). Can be created using the androidLogger() factory function. SystemOutLogger: Writes log statements to STDOUT ( println ). Can be created using the systemOutLogger() factory function. By default, the AndroidLogger is used, but you can customize which ever one you want based on your needs. The Logger interface is very simple, and you can use it to create your custom implementations as well. Enable/Disable Logging \u00b6 You can enable or disable logging by setting Vector.enableLogging .","title":"Logging"},{"location":"logging/#logging","text":"Vector can log state related actions. It ships with two different loggers: AndroidLogger: Writes log statements to Android log ( Log.* ). Can be created using the androidLogger() factory function. SystemOutLogger: Writes log statements to STDOUT ( println ). Can be created using the systemOutLogger() factory function. By default, the AndroidLogger is used, but you can customize which ever one you want based on your needs. The Logger interface is very simple, and you can use it to create your custom implementations as well.","title":"Logging"},{"location":"logging/#enabledisable-logging","text":"You can enable or disable logging by setting Vector.enableLogging .","title":"Enable/Disable Logging"},{"location":"saved-state-vectorviewmodel/","text":"SavedState VectorViewModel \u00b6 A subclass of VectorViewModel which provides easier state persistence across process deaths, by providing access to a SavedStateHandle from ViewModel SavedState library in Android Jetpack. Making state persistable \u00b6 The easiest way to persist your UI state is to simply save the entire state object using the saved state handle. However, you state class needs to implementing Parcelable for this, which is a tedious and error prone process. Luckily, Kotlin comes with an Android Extension which helps use make our classes Parcelable with just a single annotation. import kotlinx.android.parcel.Parcelize @Parcelize data class UserState ( val userId : Long = - 1 , val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable Make sure that you have turned on the experimental flag in your build.gradle file to be able to access this feature: androidExtensions { experimental = true } Persisting State \u00b6 The SavedStateVectorViewModel class has a setStateAndPersist method which is the same as the regular setState method, except that it also persists the new state. fun greetUser () = setStateAndPersist { copy ( greeting = \"Hello!\" ) } If you want to exclude some properties in your state object from being persisted, you must annotate them with @Transient . @Parcelize data class UserState ( val userId : Long = - 1 , @Transient val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable This method by default tries to persist your entire state object using KEY_SAVED_STATE key defined in this class. If you need to customize this behaviour, you should override the persistState method. override fun persistState () = withState { state -> // Your custom implementation }","title":"SavedState VectorViewModel"},{"location":"saved-state-vectorviewmodel/#savedstate-vectorviewmodel","text":"A subclass of VectorViewModel which provides easier state persistence across process deaths, by providing access to a SavedStateHandle from ViewModel SavedState library in Android Jetpack.","title":"SavedState VectorViewModel"},{"location":"saved-state-vectorviewmodel/#making-state-persistable","text":"The easiest way to persist your UI state is to simply save the entire state object using the saved state handle. However, you state class needs to implementing Parcelable for this, which is a tedious and error prone process. Luckily, Kotlin comes with an Android Extension which helps use make our classes Parcelable with just a single annotation. import kotlinx.android.parcel.Parcelize @Parcelize data class UserState ( val userId : Long = - 1 , val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable Make sure that you have turned on the experimental flag in your build.gradle file to be able to access this feature: androidExtensions { experimental = true }","title":"Making state persistable"},{"location":"saved-state-vectorviewmodel/#persisting-state","text":"The SavedStateVectorViewModel class has a setStateAndPersist method which is the same as the regular setState method, except that it also persists the new state. fun greetUser () = setStateAndPersist { copy ( greeting = \"Hello!\" ) } If you want to exclude some properties in your state object from being persisted, you must annotate them with @Transient . @Parcelize data class UserState ( val userId : Long = - 1 , @Transient val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable This method by default tries to persist your entire state object using KEY_SAVED_STATE key defined in this class. If you need to customize this behaviour, you should override the persistState method. override fun persistState () = withState { state -> // Your custom implementation }","title":"Persisting State"},{"location":"state-store-context/","text":"Coroutine Context for the State Store \u00b6 Every VectorViewModel has a backing StateHolder and a StateStore . The StateHolder is responsible for holding the current state, and the StateStore is responsible for processing state access/mutation blocks. All state related actions are processed off the main thread, in a sequential manner using a Coroutine Actor. The coroutine context for this actor is by default defined as: Dispatchers.Default + Job() . If you wish to customize the state store coroutine context, you may do so by supplying your custom context in the ViewModel. abstract class VectorViewModel < S : VectorState >( initialState : S ?, stateStoreContext : CoroutineContext = Dispatchers . Default + Job (), // <- Change this parameter in your own implementations protected val logger : Logger = androidLogger () )","title":"Coroutine Context for State Store"},{"location":"state-store-context/#coroutine-context-for-the-state-store","text":"Every VectorViewModel has a backing StateHolder and a StateStore . The StateHolder is responsible for holding the current state, and the StateStore is responsible for processing state access/mutation blocks. All state related actions are processed off the main thread, in a sequential manner using a Coroutine Actor. The coroutine context for this actor is by default defined as: Dispatchers.Default + Job() . If you wish to customize the state store coroutine context, you may do so by supplying your custom context in the ViewModel. abstract class VectorViewModel < S : VectorState >( initialState : S ?, stateStoreContext : CoroutineContext = Dispatchers . Default + Job (), // <- Change this parameter in your own implementations protected val logger : Logger = androidLogger () )","title":"Coroutine Context for the State Store"},{"location":"usage/","text":"Usage \u00b6 To demonstrate the usage of Vector, let us build an imaginary note taking app. We are going to build the screen where we show all the notes saved by our user. A screen written using Vector typically has three components: A presenter, a state class, and a ViewModel. The State class \u00b6 The state class is a model for the UI state. It should have the following characteristics: Immutable, as the data in it could be accessed by multiple threads Contain all necessary data to render the UI Have default values for their properties. Our Notes screen at the very least needs a list of all the notes of our user. Additionally, let us also add the ability to filter the notes. Here's what the state class might look like: data class NotesListState ( val notes : List < Note > = listOf (), val filter : Filter = Filter . ALL ): VectorState enum class Filter { ALL , PINNED , ARCHIVED } Vector requires that you implement the VectorState interface in your state classes. It is an empty interface, and serves only as a marker for these classes. For an in-depth look at defining state, please read Vector State . The ViewModel class \u00b6 The ViewModel class serves as a holder for UI state, and also manages mutations/access to it. It survives configuration changes, and is tied to the logical lifecycle of a Fragment or Activity. Vector provides a VectorViewModel component for this. You should extend this class in your own ViewModels. Let's use it to build our NotesListViewModel . Initial State \u00b6 class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) Our ViewModel has a dependency on an initialState object. Therefore, this ViewModel can not be handled directly with the ViewModelProviders class in the AndroidX Lifecycle library. We shall see how to get a hold of this ViewModel in the section on the presenter class . The initialState parameter represents the default state of UI. Our ViewModel needs this in order to be able to tell the presenter what to show the user when it first loads. Managing State \u00b6 A VectorViewModel exposes a Kotlin Flow of UI State to its owning Fragment/Activity. The owner can subscribe to this state flow, and render the UI according to whatever value is contained in it. From our ViewModel, whenever we produce a new state it should be pushed to this Flow, so that the UI can be informed that a new state has been created, and that it should re-render itself. When the ViewModel is first created, it sets the initialState object to the state flow. Our ViewModel is ready to get all the notes from our Repository, so let us fetch them as soon as the ViewModel is created. class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getAllNotes () } } suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val notes = Repository . allNotes () ... } } Now that we have the notes, we are ready to show them to the user. How do we do this? By modifying the current state! Modifying/Mutating state \u00b6 We can modify the current state using the setState method, like this: suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val allNotes = Repository . allNotes () setState { // `this` = the current state copy ( notes = allNotes ) } } The setState method accepts a lambda which has the current state as the receiver. This lambda is often called as a \"Reducer\" . Since we used a data class to model our state, we have a copy() method on it generated automatically for us. We can use it to produce a new state from our current state. When the setState method is called, it enqueues its reducer to an internal queue. A coroutine processes the reducers in this queue sequentially on a background thread. Hence, state updates are performed asynchronously . When this reducer is processed, the new state object produced by it is pushed to the state flow to notify the UI that it should re-render itself. All of this happens automatically, and you do not need to worry about it. So when our setState block has finished processing, our UI will be notified that it should show this list of notes to our user! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Warning Since state updates are processed asynchronously, you should not assume that you shall get the updated state immediately after the setState block. Accessing State \u00b6 Let us also add the ability to filter notes. We need to fetch notes based on what filter is set. To know what filter is currently set, we need access to the current state. The correct way to do this is to use the withState method. suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } The withState block receives the current state as a parameter. We can use to take decisions which depend on the current state. withState , just like setState , is processed asynchronously. Our ViewModel now looks like this: class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getNotes () } } suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } suspend fun getAllNotes () { ... } suspend fun getPinnedNotes () { ... } suspend fun getArchivedNotes () { ... } } The Presenter class \u00b6 The presenter class serves as the UI for your application. Vector provides a simple VectorFragment component for this. It is a subclass of the AndroidX Fragment, and has a convenient CoroutineScope to launch coroutines. Let's use it to build our NotesListFragment class. class NotesListFragment : VectorFragment () Getting hold of the ViewModel \u00b6 Our Fragment needs access to its ViewModel. We usually use the ViewModelProviders class for this, but this will not work here , unless we create our own ViewModelProvider.Factory which knows how to create our ViewModel. Even then, the factory might not know how to create the initial state in more complex use cases. Vector provides some convenient lazy delegates to take care of this for you. From inside a fragment, we can request a ViewModel scoped to a fragment like this: class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () } This will lazily instantiate the ViewModel for you! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Note ViewModel delegates supplied by Vector can only create ViewModels with the same dependencies as the VectorViewModel class. If you have other dependencies in your ViewModel's constructor, please take a look at the \"ViewModels with additional dependencies\" section in the documentation for VectorViewModel . Observing state \u00b6 Now that we have our ViewModel, we can start observing state changes. To do this, we need to subscribe to the state flow exposed by the ViewModel. Subscribing to a Flow requires a Coroutine Scope, and luckily VectorFragment provides us with one. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onCreate () { ... fragmentScope . launch { viewModel . state . collect { state -> recyclerViewAdapter . submitList ( state . notes ) } } } } The fragmentScope property is a Coroutine Scope which is cancelled when the Fragment's onDestroy() callback is called. This action of subscribing to state changes can be done more concisely using the renderState() method in the VectorFragment class. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onCreate () { ... renderState ( viewModel ) { state -> recyclerViewAdapter . submitList ( state . notes ) } } } Now whenever we get a new state object from our ViewModel, we automaticall update the user interface! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Sending Actions to the ViewModel \u00b6 We have established how a ViewModel communicates with the presenter, but not how a presenter communicates with the ViewModel. In MVI-speak, presenter communicates with the ViewModel through Intents , or Actions . We are not referring to the android.content.Intent class here. Vector does not need you to define any classes which specify your Actions . A simpler way to communicate actions to the ViewModel is to simply call methods on it. Whenever the user changes their filter setting, we must notify our ViewModel. Let us add a method on our ViewModel to set a filter. class NotesListViewModel(...): VectorViewModel<NotesListState>(...) { fun changeFilter(newFilter: Filter) = setState { copy(filter = newFilter) getNotes() } } Now whenever the user sets a new filter, we fetch notes for it and update our state. The UI then re-renders according to the updated state. We have a working Notes list screen now! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Advanced usage \u00b6 For more advanced use cases, such as dependency injection in a ViewModel, automatic state persistence across process deaths, customization of state store Coroutine Context, logging and more, please explore the relevant sections under the Component section in the navigation bar.","title":"Usage"},{"location":"usage/#usage","text":"To demonstrate the usage of Vector, let us build an imaginary note taking app. We are going to build the screen where we show all the notes saved by our user. A screen written using Vector typically has three components: A presenter, a state class, and a ViewModel.","title":"Usage"},{"location":"usage/#the-state-class","text":"The state class is a model for the UI state. It should have the following characteristics: Immutable, as the data in it could be accessed by multiple threads Contain all necessary data to render the UI Have default values for their properties. Our Notes screen at the very least needs a list of all the notes of our user. Additionally, let us also add the ability to filter the notes. Here's what the state class might look like: data class NotesListState ( val notes : List < Note > = listOf (), val filter : Filter = Filter . ALL ): VectorState enum class Filter { ALL , PINNED , ARCHIVED } Vector requires that you implement the VectorState interface in your state classes. It is an empty interface, and serves only as a marker for these classes. For an in-depth look at defining state, please read Vector State .","title":"The State class"},{"location":"usage/#the-viewmodel-class","text":"The ViewModel class serves as a holder for UI state, and also manages mutations/access to it. It survives configuration changes, and is tied to the logical lifecycle of a Fragment or Activity. Vector provides a VectorViewModel component for this. You should extend this class in your own ViewModels. Let's use it to build our NotesListViewModel .","title":"The ViewModel class"},{"location":"usage/#initial-state","text":"class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) Our ViewModel has a dependency on an initialState object. Therefore, this ViewModel can not be handled directly with the ViewModelProviders class in the AndroidX Lifecycle library. We shall see how to get a hold of this ViewModel in the section on the presenter class . The initialState parameter represents the default state of UI. Our ViewModel needs this in order to be able to tell the presenter what to show the user when it first loads.","title":"Initial State"},{"location":"usage/#managing-state","text":"A VectorViewModel exposes a Kotlin Flow of UI State to its owning Fragment/Activity. The owner can subscribe to this state flow, and render the UI according to whatever value is contained in it. From our ViewModel, whenever we produce a new state it should be pushed to this Flow, so that the UI can be informed that a new state has been created, and that it should re-render itself. When the ViewModel is first created, it sets the initialState object to the state flow. Our ViewModel is ready to get all the notes from our Repository, so let us fetch them as soon as the ViewModel is created. class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getAllNotes () } } suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val notes = Repository . allNotes () ... } } Now that we have the notes, we are ready to show them to the user. How do we do this? By modifying the current state!","title":"Managing State"},{"location":"usage/#modifyingmutating-state","text":"We can modify the current state using the setState method, like this: suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val allNotes = Repository . allNotes () setState { // `this` = the current state copy ( notes = allNotes ) } } The setState method accepts a lambda which has the current state as the receiver. This lambda is often called as a \"Reducer\" . Since we used a data class to model our state, we have a copy() method on it generated automatically for us. We can use it to produce a new state from our current state. When the setState method is called, it enqueues its reducer to an internal queue. A coroutine processes the reducers in this queue sequentially on a background thread. Hence, state updates are performed asynchronously . When this reducer is processed, the new state object produced by it is pushed to the state flow to notify the UI that it should re-render itself. All of this happens automatically, and you do not need to worry about it. So when our setState block has finished processing, our UI will be notified that it should show this list of notes to our user! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Warning Since state updates are processed asynchronously, you should not assume that you shall get the updated state immediately after the setState block.","title":"Modifying/Mutating state"},{"location":"usage/#accessing-state","text":"Let us also add the ability to filter notes. We need to fetch notes based on what filter is set. To know what filter is currently set, we need access to the current state. The correct way to do this is to use the withState method. suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } The withState block receives the current state as a parameter. We can use to take decisions which depend on the current state. withState , just like setState , is processed asynchronously. Our ViewModel now looks like this: class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getNotes () } } suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } suspend fun getAllNotes () { ... } suspend fun getPinnedNotes () { ... } suspend fun getArchivedNotes () { ... } }","title":"Accessing State"},{"location":"usage/#the-presenter-class","text":"The presenter class serves as the UI for your application. Vector provides a simple VectorFragment component for this. It is a subclass of the AndroidX Fragment, and has a convenient CoroutineScope to launch coroutines. Let's use it to build our NotesListFragment class. class NotesListFragment : VectorFragment ()","title":"The Presenter class"},{"location":"usage/#getting-hold-of-the-viewmodel","text":"Our Fragment needs access to its ViewModel. We usually use the ViewModelProviders class for this, but this will not work here , unless we create our own ViewModelProvider.Factory which knows how to create our ViewModel. Even then, the factory might not know how to create the initial state in more complex use cases. Vector provides some convenient lazy delegates to take care of this for you. From inside a fragment, we can request a ViewModel scoped to a fragment like this: class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () } This will lazily instantiate the ViewModel for you! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Note ViewModel delegates supplied by Vector can only create ViewModels with the same dependencies as the VectorViewModel class. If you have other dependencies in your ViewModel's constructor, please take a look at the \"ViewModels with additional dependencies\" section in the documentation for VectorViewModel .","title":"Getting hold of the ViewModel"},{"location":"usage/#observing-state","text":"Now that we have our ViewModel, we can start observing state changes. To do this, we need to subscribe to the state flow exposed by the ViewModel. Subscribing to a Flow requires a Coroutine Scope, and luckily VectorFragment provides us with one. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onCreate () { ... fragmentScope . launch { viewModel . state . collect { state -> recyclerViewAdapter . submitList ( state . notes ) } } } } The fragmentScope property is a Coroutine Scope which is cancelled when the Fragment's onDestroy() callback is called. This action of subscribing to state changes can be done more concisely using the renderState() method in the VectorFragment class. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onCreate () { ... renderState ( viewModel ) { state -> recyclerViewAdapter . submitList ( state . notes ) } } } Now whenever we get a new state object from our ViewModel, we automaticall update the user interface! \ud83c\udf89\ud83c\udf89\ud83c\udf89","title":"Observing state"},{"location":"usage/#sending-actions-to-the-viewmodel","text":"We have established how a ViewModel communicates with the presenter, but not how a presenter communicates with the ViewModel. In MVI-speak, presenter communicates with the ViewModel through Intents , or Actions . We are not referring to the android.content.Intent class here. Vector does not need you to define any classes which specify your Actions . A simpler way to communicate actions to the ViewModel is to simply call methods on it. Whenever the user changes their filter setting, we must notify our ViewModel. Let us add a method on our ViewModel to set a filter. class NotesListViewModel(...): VectorViewModel<NotesListState>(...) { fun changeFilter(newFilter: Filter) = setState { copy(filter = newFilter) getNotes() } } Now whenever the user sets a new filter, we fetch notes for it and update our state. The UI then re-renders according to the updated state. We have a working Notes list screen now! \ud83c\udf89\ud83c\udf89\ud83c\udf89","title":"Sending Actions to the ViewModel"},{"location":"usage/#advanced-usage","text":"For more advanced use cases, such as dependency injection in a ViewModel, automatic state persistence across process deaths, customization of state store Coroutine Context, logging and more, please explore the relevant sections under the Component section in the navigation bar.","title":"Advanced usage"},{"location":"vector-fragment/","text":"Vector Fragment \u00b6 Vector Fragment is an abstract class that extends the AndroidX Fragment class. You are not required to use it, the only benefit it offers is that it has a convenient fragmentScope Couroutine Scope which can be used to easily launch Coroutines. VectorFragment class also has an abstract renderState(state: S, renderer: (S) -> Unit) method, which should be overridden by subclasses. It is supposed to be the place where Views update themselves. You are free to choose your own implementation and not extend from VectorFragment at all. An example of how the renderState function should look like: class UsersListFragment : VectorFragment () { private val viewModel : UserViewModel by viewModel () override fun onCreate (...) { renderState ( viewModel ) { state -> // Update your views here } } } Vector is not opinionated about what should be used as Views in an app, so please feel free to use whatever you like. However, the VectorViewModel class exposes the current state observable as a Kotlin Flow object, so it helps if your View object is a CoroutineScope .","title":"Vector Fragment"},{"location":"vector-fragment/#vector-fragment","text":"Vector Fragment is an abstract class that extends the AndroidX Fragment class. You are not required to use it, the only benefit it offers is that it has a convenient fragmentScope Couroutine Scope which can be used to easily launch Coroutines. VectorFragment class also has an abstract renderState(state: S, renderer: (S) -> Unit) method, which should be overridden by subclasses. It is supposed to be the place where Views update themselves. You are free to choose your own implementation and not extend from VectorFragment at all. An example of how the renderState function should look like: class UsersListFragment : VectorFragment () { private val viewModel : UserViewModel by viewModel () override fun onCreate (...) { renderState ( viewModel ) { state -> // Update your views here } } } Vector is not opinionated about what should be used as Views in an app, so please feel free to use whatever you like. However, the VectorViewModel class exposes the current state observable as a Kotlin Flow object, so it helps if your View object is a CoroutineScope .","title":"Vector Fragment"},{"location":"vector-state/","text":"Vector State \u00b6 Vector recommends using immutable Kotlin Data Classes to represent your UI Model classes. Such classes should implement the VectorState interface, because the VectorViewModel class is generic on a subtype of this interface. It is recommended to keep your state classes immutable, otherwise you risk your UI model getting into inconsistent states when there are multiple sources producing state updates concurrently. Example \u00b6 data class ProfilePageState ( val user : User , val isLoading : Boolean , val isError : Boolean ): VectorState Using a Data Class provides the benefit of the automatically generated copy() method. It allows you to mutate the state very easily, you just need to provide the values that have actually changed, and the others will be kept the same. For example, if the User Profile page in the above example starts in the Loading state, the initial state model would look like this: val initialState = ProfilePageState ( user = cachedUser , isLoading = true , isError = false ) When the loading completes, the state can be mutated easily like this: val newState = initialState . copy ( user = userRetrievedFromNetwork , isLoading = false ) Since the isError variable value remains the same (false), we do not need to supply it in the copy method. Sealed Class based Model Classes \u00b6 A great way to represent all possible states a screen can be in is using Kotlin's Sealed Classes. Continuing the profile page example, suppose we want to show a different types of information based on whether the user is a premium user or not. We can do it this way: sealed class ProfilePageState : VectorState { data class PremiumProfilePage ( val user : User , val accountPerks : List < Perks >, val isLoading : Boolean , val isError : Boolean ): ProfilePageState () data class StandardProfilePage ( val user : User , val isLoading : Boolean , val isError : Boolean ): ProfilePageState () } This allows you to separate similar, but related states of a screen. It increases verbosity though, and you lose direct access to convenient data class methods, unless you type cast the state object into one of its subclasses. Persistable state \u00b6 Kotlin Extensions for Android have the ability to automatically generate Parcelable implementations of data classes with the @Parcelize annotation. This can be leveraged to easily persist state classes when needed. @Parcelize data class ProfilePageState ( ... ): Parcelable When needed, this state can be directly put as a Serializable into a SavedInstanceState bundle or a SavedStateHandle in a ViewModel. For members in your state class which should not be persisted, @Transient annotation can be used. @Parcelize data class ProfilePageState ( val userId : Long , @Transient val user : User ): VectorState Doing this ensures that the transient values in the state object are not persisted. Info Your state object should only persist the minimum amount of information required to rebuild it fully after a process death. Automatic State Restoration \u00b6 If you use the lazy ViewModel delegates shipped with Vector, you must ensure that either: Your state class has default values for every property, or Your ViewModel class implements the VectorViewModelFactory interface along with its initialState method This is to ensure that we can create an instance of your state class automatically.","title":"Vector State"},{"location":"vector-state/#vector-state","text":"Vector recommends using immutable Kotlin Data Classes to represent your UI Model classes. Such classes should implement the VectorState interface, because the VectorViewModel class is generic on a subtype of this interface. It is recommended to keep your state classes immutable, otherwise you risk your UI model getting into inconsistent states when there are multiple sources producing state updates concurrently.","title":"Vector State"},{"location":"vector-state/#example","text":"data class ProfilePageState ( val user : User , val isLoading : Boolean , val isError : Boolean ): VectorState Using a Data Class provides the benefit of the automatically generated copy() method. It allows you to mutate the state very easily, you just need to provide the values that have actually changed, and the others will be kept the same. For example, if the User Profile page in the above example starts in the Loading state, the initial state model would look like this: val initialState = ProfilePageState ( user = cachedUser , isLoading = true , isError = false ) When the loading completes, the state can be mutated easily like this: val newState = initialState . copy ( user = userRetrievedFromNetwork , isLoading = false ) Since the isError variable value remains the same (false), we do not need to supply it in the copy method.","title":"Example"},{"location":"vector-state/#sealed-class-based-model-classes","text":"A great way to represent all possible states a screen can be in is using Kotlin's Sealed Classes. Continuing the profile page example, suppose we want to show a different types of information based on whether the user is a premium user or not. We can do it this way: sealed class ProfilePageState : VectorState { data class PremiumProfilePage ( val user : User , val accountPerks : List < Perks >, val isLoading : Boolean , val isError : Boolean ): ProfilePageState () data class StandardProfilePage ( val user : User , val isLoading : Boolean , val isError : Boolean ): ProfilePageState () } This allows you to separate similar, but related states of a screen. It increases verbosity though, and you lose direct access to convenient data class methods, unless you type cast the state object into one of its subclasses.","title":"Sealed Class based Model Classes"},{"location":"vector-state/#persistable-state","text":"Kotlin Extensions for Android have the ability to automatically generate Parcelable implementations of data classes with the @Parcelize annotation. This can be leveraged to easily persist state classes when needed. @Parcelize data class ProfilePageState ( ... ): Parcelable When needed, this state can be directly put as a Serializable into a SavedInstanceState bundle or a SavedStateHandle in a ViewModel. For members in your state class which should not be persisted, @Transient annotation can be used. @Parcelize data class ProfilePageState ( val userId : Long , @Transient val user : User ): VectorState Doing this ensures that the transient values in the state object are not persisted. Info Your state object should only persist the minimum amount of information required to rebuild it fully after a process death.","title":"Persistable state"},{"location":"vector-state/#automatic-state-restoration","text":"If you use the lazy ViewModel delegates shipped with Vector, you must ensure that either: Your state class has default values for every property, or Your ViewModel class implements the VectorViewModelFactory interface along with its initialState method This is to ensure that we can create an instance of your state class automatically.","title":"Automatic State Restoration"},{"location":"vector-viewmodel/","text":"Vector ViewModel \u00b6 The VectorViewModel class is the place where the UI state is stored. It is also the only place which can perform changes to the UI state. You must extend this class in your own ViewModels. It is generic on a state class implementing the VectorState interface. data class UserState (...): VectorState class UserViewModel ( initialState : UsersState ): VectorViewModel < UsersState >( initialState ) { ... } Creating a ViewModel \u00b6 A ViewModel is scoped to the Lifecycle of its owning Fragment or Activity. An Activity can access Activity-scoped ViewModels, whereas Fragments can create both Fragment-scoped and Activity-scoped ViewModels. The library ships with a few Kotlin property delegates which make it easy to create a VectorViewModel for whichever scope you need. From a Fragment: val userViewModel : UserViewModel by fragmentViewModel () // Scoped to this fragment // OR val userViewModel : UserViewModel by activityViewModel () // Scoped to the parent activity From an Activity: val userViewModel : UserViewModel by viewModel () // Scoped to this activity These delegates automatically create the ViewModel for you, as long as they do not have any external dependencies. ViewModels with additional dependencies \u00b6 If your ViewModel has external dependencies, then you should use an alternative version of these delegates which accepts a trailing lambda that should contain the code to create your ViewModel. val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , UserRepository ()) } Alternatively, you can choose to implement the VectorViewModelFactory interface in your ViewModel's companion object to provide your own implementation for its create and initialState methods. class UserViewModel ( initialState : UserState , val repository : UserRepository ) { ... companion object : VectorViewModelFactory < UserViewModel , UserState > { override fun initialState ( handle : SavedStateHandle , owner : ViewModelOwner ): UserState ? { // Create state object directly or restore it using `SavedStateHandle` } override fun create ( initialState : UserState , owner : ViewModelOwner , handle : SavedStateHandle ): UserViewModel ? { // Create and return your ViewModel // the `owner` parameter can be used to access your DI graph } } } Support for AssistedInject factories \u00b6 If you use Dagger and AssistedInject in your project, then you can create ViewModels in this way: @Inject val usersViewModelFactory : UsersViewModel . Factory // The AssistedInject factory val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> userViewModelFactory . create ( initialState , ...) } Managing State \u00b6 Mutating State \u00b6 State mutation is done through the setState function, which accepts regular lambdas as well as suspending lambdas . The supplied lambda is given the current state as the receiver , and it is responsible for creating a new state and returning it. class UserViewModel (...): VectorViewModel < UserState >(...) { fun greetUser () = setState { val currentState = this // this = current state val newState = UsersState ( greeting = \"Hello!\" , user = currentState . user ) newState } } If the state class is a Kotlin Data class , then this can be expressed succintly as: fun greetUser () = setState { copy ( greeting = \"Hello!\" ) } This works because the this received in the setState block is the current state, which has a copy method define for it by virtue of being a data class. Note State mutations are processed asynchronously. You should not rely on the state to be updated immediately after you call the setState function. Every state mutation is enqueued to a Channel on a background thread, which processes them sequentially to avoid race conditions. Accessing State \u00b6 If you need to access the current state and perform some action based on it, you should use the withState function. It receives the current state as a parameter, and can then use it to perform decisions based on it. fun greetUser () = withState { state -> if ( state . isUserPremium ()) { setState { copy ( greeting = \"Hello, premium user!\" ) } } else { setState { copy ( greeting = \"Hello!\" )} } } withState blocks, just like setState blocks, are processed on a background thread asynchronously. The state parameter supplied to withState is guaranteed to be the latest state at the time of processing the lambda. Any nested setState blocks are processed immediately, before any other withState blocks can be processed. Warning While there are other ways to access the state in your ViewModel, using the withState function is the safest way to do so. Since state updates are processed asynchronously, other methods are not guaranteed to have the latest state when you access it. The withState block always receives the latest state as a parameter when it is processed. Note There's also a currentState property in a VectorViewModel , but it should not be used in place of a withState block. currentState only provides a convenient way for external classes to access the current state without subscribing to it. Observing state changes \u00b6 A VectorViewModel exposes state to fragments and activities through a Kotlin Flow . A Flow is a cold stream of values, which is active only while there is someone subscribing to it. You can subscribe to state changes like this: class UserActivity : AppCompatActivity () { private val userViewModel : UserViewModel by viewModel () private val coroutineScope = MainScope () override fun onCreate (...) { coroutineScope . launch { userViewModel . state . collect { state -> updateState ( state ) } } } fun updateState ( state : UserState ) { ... } override fun onDestroy (...) { coroutineScope . cancel () } } Example \u00b6 Here's an example of how to use the VectorViewModel: data class UserState ( val user : User ? = null , isError : Boolean = false , isLoading : Boolean = false ): VectorState class UserViewModel ( initState : UserState , private val repository : UserRepository ): VectorViewModel < UsersState >( initState ) { init { viewModelScope . launch { getUserDetails () } } private suspend fun getUserDetails () { setState { copy ( isLoading = true ) } val users = repository . getUser () if ( user == null ) { setState { copy ( user = null , isError = true , isLoading = false ) } } else { setState { copy ( usersList = users , isLoading = false ) } } } } class UserFragment : VectorFragment () { private val viewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , savedStateHandle ) } override fun onCreate (...) { renderState ( viewModel ) { state -> ... } } } Warning ViewModels only survive configuration changes such as screen rotations. They do NOT survive process death. State Persistence \u00b6 While ViewModels are great for storing UI state because they survive configuration changes, you still need to take care of persisting your UI state in the event of a process death. To make this process easier, the library ships with a specialized version of VectorViewModel , named the SavedStateVectorViewModel which leverages the ViewModel SavedState Module for state persistence.","title":"Vector ViewModel"},{"location":"vector-viewmodel/#vector-viewmodel","text":"The VectorViewModel class is the place where the UI state is stored. It is also the only place which can perform changes to the UI state. You must extend this class in your own ViewModels. It is generic on a state class implementing the VectorState interface. data class UserState (...): VectorState class UserViewModel ( initialState : UsersState ): VectorViewModel < UsersState >( initialState ) { ... }","title":"Vector ViewModel"},{"location":"vector-viewmodel/#creating-a-viewmodel","text":"A ViewModel is scoped to the Lifecycle of its owning Fragment or Activity. An Activity can access Activity-scoped ViewModels, whereas Fragments can create both Fragment-scoped and Activity-scoped ViewModels. The library ships with a few Kotlin property delegates which make it easy to create a VectorViewModel for whichever scope you need. From a Fragment: val userViewModel : UserViewModel by fragmentViewModel () // Scoped to this fragment // OR val userViewModel : UserViewModel by activityViewModel () // Scoped to the parent activity From an Activity: val userViewModel : UserViewModel by viewModel () // Scoped to this activity These delegates automatically create the ViewModel for you, as long as they do not have any external dependencies.","title":"Creating a ViewModel"},{"location":"vector-viewmodel/#viewmodels-with-additional-dependencies","text":"If your ViewModel has external dependencies, then you should use an alternative version of these delegates which accepts a trailing lambda that should contain the code to create your ViewModel. val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , UserRepository ()) } Alternatively, you can choose to implement the VectorViewModelFactory interface in your ViewModel's companion object to provide your own implementation for its create and initialState methods. class UserViewModel ( initialState : UserState , val repository : UserRepository ) { ... companion object : VectorViewModelFactory < UserViewModel , UserState > { override fun initialState ( handle : SavedStateHandle , owner : ViewModelOwner ): UserState ? { // Create state object directly or restore it using `SavedStateHandle` } override fun create ( initialState : UserState , owner : ViewModelOwner , handle : SavedStateHandle ): UserViewModel ? { // Create and return your ViewModel // the `owner` parameter can be used to access your DI graph } } }","title":"ViewModels with additional dependencies"},{"location":"vector-viewmodel/#support-for-assistedinject-factories","text":"If you use Dagger and AssistedInject in your project, then you can create ViewModels in this way: @Inject val usersViewModelFactory : UsersViewModel . Factory // The AssistedInject factory val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> userViewModelFactory . create ( initialState , ...) }","title":"Support for AssistedInject factories"},{"location":"vector-viewmodel/#managing-state","text":"","title":"Managing State"},{"location":"vector-viewmodel/#mutating-state","text":"State mutation is done through the setState function, which accepts regular lambdas as well as suspending lambdas . The supplied lambda is given the current state as the receiver , and it is responsible for creating a new state and returning it. class UserViewModel (...): VectorViewModel < UserState >(...) { fun greetUser () = setState { val currentState = this // this = current state val newState = UsersState ( greeting = \"Hello!\" , user = currentState . user ) newState } } If the state class is a Kotlin Data class , then this can be expressed succintly as: fun greetUser () = setState { copy ( greeting = \"Hello!\" ) } This works because the this received in the setState block is the current state, which has a copy method define for it by virtue of being a data class. Note State mutations are processed asynchronously. You should not rely on the state to be updated immediately after you call the setState function. Every state mutation is enqueued to a Channel on a background thread, which processes them sequentially to avoid race conditions.","title":"Mutating State"},{"location":"vector-viewmodel/#accessing-state","text":"If you need to access the current state and perform some action based on it, you should use the withState function. It receives the current state as a parameter, and can then use it to perform decisions based on it. fun greetUser () = withState { state -> if ( state . isUserPremium ()) { setState { copy ( greeting = \"Hello, premium user!\" ) } } else { setState { copy ( greeting = \"Hello!\" )} } } withState blocks, just like setState blocks, are processed on a background thread asynchronously. The state parameter supplied to withState is guaranteed to be the latest state at the time of processing the lambda. Any nested setState blocks are processed immediately, before any other withState blocks can be processed. Warning While there are other ways to access the state in your ViewModel, using the withState function is the safest way to do so. Since state updates are processed asynchronously, other methods are not guaranteed to have the latest state when you access it. The withState block always receives the latest state as a parameter when it is processed. Note There's also a currentState property in a VectorViewModel , but it should not be used in place of a withState block. currentState only provides a convenient way for external classes to access the current state without subscribing to it.","title":"Accessing State"},{"location":"vector-viewmodel/#observing-state-changes","text":"A VectorViewModel exposes state to fragments and activities through a Kotlin Flow . A Flow is a cold stream of values, which is active only while there is someone subscribing to it. You can subscribe to state changes like this: class UserActivity : AppCompatActivity () { private val userViewModel : UserViewModel by viewModel () private val coroutineScope = MainScope () override fun onCreate (...) { coroutineScope . launch { userViewModel . state . collect { state -> updateState ( state ) } } } fun updateState ( state : UserState ) { ... } override fun onDestroy (...) { coroutineScope . cancel () } }","title":"Observing state changes"},{"location":"vector-viewmodel/#example","text":"Here's an example of how to use the VectorViewModel: data class UserState ( val user : User ? = null , isError : Boolean = false , isLoading : Boolean = false ): VectorState class UserViewModel ( initState : UserState , private val repository : UserRepository ): VectorViewModel < UsersState >( initState ) { init { viewModelScope . launch { getUserDetails () } } private suspend fun getUserDetails () { setState { copy ( isLoading = true ) } val users = repository . getUser () if ( user == null ) { setState { copy ( user = null , isError = true , isLoading = false ) } } else { setState { copy ( usersList = users , isLoading = false ) } } } } class UserFragment : VectorFragment () { private val viewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , savedStateHandle ) } override fun onCreate (...) { renderState ( viewModel ) { state -> ... } } } Warning ViewModels only survive configuration changes such as screen rotations. They do NOT survive process death.","title":"Example"},{"location":"vector-viewmodel/#state-persistence","text":"While ViewModels are great for storing UI state because they survive configuration changes, you still need to take care of persisting your UI state in the event of a process death. To make this process easier, the library ships with a specialized version of VectorViewModel , named the SavedStateVectorViewModel which leverages the ViewModel SavedState Module for state persistence.","title":"State Persistence"}]}